# ABC130

## A - Rounding
- cout << (x>=A)*10;

## B - Bounding
- シミュレーションしてみれば良い

## C - Rectangle Cutting
- 小さくない方の面積を最大化->出来るだけ面積が均等になるように分割する。  
- 任意の(x,y)で等しい面積二つに分割できることがわかるので、面積の答えは(h*w)/2。double  
- また、2*x==hかつ2*y==wならば複数(無限に)分割パターンがあるので、その場合のみ1  

## D - Enough Array
- しゃくとり法の典型問題。配列の要素は全て正なので優しい。  
- しゃくとり法を使うときはフローチャートを考える。  
0. 初期条件: s=0,t=0。res=0,sum=a[0]。  
1. t<n&&s<n？ :YES ->2.へ :NO->終了
2. sum>=k？ :YES-> 3.へ :NO-> 6.へ
3. s==t？ :YES->4.へ NO:->5.へ
4. s++;t++;sum=a[s]; ->1.へ
5. sum-=a[s];s++; ->1.へ
6. t++;sum += a[t]; ->1.へ

## E - Common Subsequence
- DPであることはすぐわかる。最長共通部分列っぽい。  
- 最長共通部分列では、文字列S、T、dp[i][j]として dp[i][j] := S[i],T[j]まで見たときの最長共通部分列。　であった。  
- 今回は最長の部分列の長さではなく、部分列の数である。そこで、dp[i][j] := S[i]、T[j]を末尾にする場合の共通部分列の総数としてみる。  
- すると、遷移はdp[i][j] = Σ_{a=0}^{a=i-1} Σ_{b=0}^{b=j-1} dp[a][b] + 1 ( S[i]==T[j]の場合)  
- これは、S[i],T[j]を末尾にもつ共通部分列は、S[i-1],T[j-1]以前で作られる共通部分列の末尾にS[i]、T[j]をくっつけたものと、S[i]、T[j]のみからなる部分列のみであるということである。  
- 総和の部分を毎回計算してしまうとTLEなので、二次元累積和を用いる。  
- 基本的な二次元累積和の更新 sum[i+1][j+1] = dp[i][j] + sum[i+1][j] + sum[i][j+1] - sum[i][j]。  
