# ABC128 

## A - Apple Pie
res = (3*A+P)/2;

## B - Guidebook
pair<pair<string,int>,int>> {{市名,点数},index} にデータを格納。  
ソートオプションで市名が同じときは点数の高い順に並ぶようにする。  
(点数に-1をかけて配列に入れるとオプションをつけなくても良いので楽)  

## C - Switches
bit全探索。添え字がややこしいので落ち着いてやろう。  

## D - equeue
### 考えたこと
- DPかな？と思ったが、戦略的に負の価値の宝石をとるパターンが考えられるので、単純にi個取った時の最大価値ではうまくいかない気がする。  
- 戻す操作(C,D)に関しては最後に行っても問題ない。戻したものを取り返す行為は無駄なので。  
- N,Kが非常に小さいので、右からi個とり、左からj個とることにして(i,j)を全探索できる。i+j個とったのちにk-(i+j)個返すことを考える。  
- 戻すk-(i+j)個は負の価値を持つ宝石だけを絶対値の大きい順に返していけば良い。  

## E - Roadwork
### 考えたこと
- s[i],t[i],x[i]の情報から、x[i]で止めることができる人間のスタート時間の範囲がわかる。[s[i]-x[i],t[i]-x[i]) となる。  
- 後は区間更新セグ木でシミュレーション？<-時間の範囲は0~10^9なので不可能。  
- imos法のようなシミュレーション方法を考える。  
  - イベントソートを行う。イベントを入れる配列と、現時点で通行止になっている座標を持つsetを用意する。  
  - イベントは次の3つ。  
    1. 追加イベント - (s[i]-x[i],1,x[i]) setにx[i]を追加する。  
    2. 削除イベント - (t[i]-x[i],0,x[i]) setからx[i]を削除する。  
    3. 解答イベント - (d[j],2,any) setの先頭を取得してくる。setが空なら-1。　　
  これらのイベントをソートして順に行えば、時間内にシミュレーションできる。
  
  
